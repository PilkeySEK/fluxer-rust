/*
 * Fluxer API
 *
 * API for Fluxer, a free and open source instant messaging and VoIP platform built for friends, groups, and communities.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developers@fluxer.app
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`add_guild_member_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddGuildMemberRoleError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ban_guild_member2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BanGuildMember2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_create_guild_emojis`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkCreateGuildEmojisError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_create_guild_stickers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkCreateGuildStickersError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_guild`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGuildError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_guild_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGuildChannelError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_guild_emoji`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGuildEmojiError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_guild_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGuildRoleError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_guild_sticker`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGuildStickerError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_guild2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGuild2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_guild_emoji`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGuildEmojiError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_guild_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGuildRoleError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_guild_sticker`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteGuildStickerError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_current_guild_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCurrentGuildMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_guild`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGuildError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_guild_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGuildMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_guild_vanity_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGuildVanityUrlError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`leave_guild`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LeaveGuildError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_audit_logs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildAuditLogsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_bans`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildBansError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildChannelsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_emojis2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildEmojis2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_members2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildMembers2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_roles`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildRolesError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_stickers2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildStickers2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guilds`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_guild_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveGuildMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_guild_member_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveGuildMemberRoleError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_role_hoist_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetRoleHoistPositionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_guild_members`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchGuildMembersError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`toggle_detached_banner`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToggleDetachedBannerError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`toggle_text_channel_flexible_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ToggleTextChannelFlexibleNamesError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`transfer_guild_ownership2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TransferGuildOwnership2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unban_guild_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnbanGuildMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_current_guild_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCurrentGuildMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_channel_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildChannelPositionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_emoji`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildEmojiError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_member`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildMemberError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_role`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildRoleError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_role_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildRolePositionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_sticker`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildStickerError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_guild_vanity_url`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGuildVanityUrlError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_role_hoist_positions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateRoleHoistPositionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// Add role to guild member. Requires `manage_roles` permission. Grants the specified role to the user in the guild.
pub async fn add_guild_member_role(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
    role_id: &str,
) -> Result<(), Error<AddGuildMemberRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;
    let p_path_role_id = role_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/{user_id}/roles/{role_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id),
        role_id = crate::apis::urlencode(p_path_role_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddGuildMemberRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Ban guild member. Requires `ban_members` permission. Prevents user from joining; optionally deletes recent messages and sets ban expiry duration.
pub async fn ban_guild_member2(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
    guild_ban_create_request: models::GuildBanCreateRequest,
) -> Result<(), Error<BanGuildMember2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;
    let p_body_guild_ban_create_request = guild_ban_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/bans/{user_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_ban_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<BanGuildMember2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Bulk create guild emojis. Requires `manage_emojis` permission. Creates multiple emojis in a single request for efficiency.
pub async fn bulk_create_guild_emojis(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_emoji_bulk_create_request: models::GuildEmojiBulkCreateRequest,
) -> Result<models::GuildEmojiBulkCreateResponse, Error<BulkCreateGuildEmojisError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_emoji_bulk_create_request = guild_emoji_bulk_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/emojis/bulk",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_emoji_bulk_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildEmojiBulkCreateResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildEmojiBulkCreateResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkCreateGuildEmojisError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Bulk create guild stickers. Requires `manage_emojis` permission. Creates multiple stickers in a single request for efficiency.
pub async fn bulk_create_guild_stickers(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_sticker_bulk_create_request: models::GuildStickerBulkCreateRequest,
) -> Result<models::GuildStickerBulkCreateResponse, Error<BulkCreateGuildStickersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_sticker_bulk_create_request = guild_sticker_bulk_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/stickers/bulk",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_sticker_bulk_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildStickerBulkCreateResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildStickerBulkCreateResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkCreateGuildStickersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Only authenticated users can create guilds.
pub async fn create_guild(
    configuration: &configuration::Configuration,
    guild_create_request: models::GuildCreateRequest,
) -> Result<models::GuildResponse, Error<CreateGuildError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_guild_create_request = guild_create_request;

    let uri_str = format!("{}/guilds", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGuildError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create guild channel. Requires `manage_channels` permission. Creates a new text, voice, or category channel in the guild.
pub async fn create_guild_channel(
    configuration: &configuration::Configuration,
    guild_id: &str,
    channel_create_request: models::ChannelCreateRequest,
) -> Result<models::ChannelResponse, Error<CreateGuildChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_channel_create_request = channel_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/channels",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_channel_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::ChannelResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ChannelResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGuildChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create guild emoji. Requires `manage_emojis` permission. Uploads and registers a new custom emoji for the guild.
pub async fn create_guild_emoji(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_emoji_create_request: models::GuildEmojiCreateRequest,
) -> Result<models::GuildEmojiResponse, Error<CreateGuildEmojiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_emoji_create_request = guild_emoji_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/emojis",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_emoji_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildEmojiResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildEmojiResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGuildEmojiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create guild role. Requires `manage_roles` permission. Creates a new role with specified name, permissions, and color.
pub async fn create_guild_role(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_role_create_request: models::GuildRoleCreateRequest,
) -> Result<models::GuildRoleResponse, Error<CreateGuildRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_role_create_request = guild_role_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_role_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildRoleResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildRoleResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGuildRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create guild sticker. Requires `manage_emojis` permission. Uploads a new sticker with name, description, and tags.
pub async fn create_guild_sticker(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_sticker_create_request: models::GuildStickerCreateRequest,
) -> Result<models::GuildStickerResponse, Error<CreateGuildStickerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_sticker_create_request = guild_sticker_create_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/stickers",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_sticker_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildStickerResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildStickerResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGuildStickerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Only guild owner can delete. Requires sudo mode verification (MFA). Permanently deletes the guild and all associated data.
pub async fn delete_guild2(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_delete_request: models::GuildDeleteRequest,
) -> Result<(), Error<DeleteGuild2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_delete_request = guild_delete_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/delete",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_delete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGuild2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete guild emoji. Requires `manage_emojis` permission. Removes a custom emoji from the guild; optionally purges all references.
pub async fn delete_guild_emoji(
    configuration: &configuration::Configuration,
    guild_id: &str,
    emoji_id: &str,
    purge: Option<&str>,
) -> Result<(), Error<DeleteGuildEmojiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_emoji_id = emoji_id;
    let p_query_purge = purge;

    let uri_str = format!(
        "{}/guilds/{guild_id}/emojis/{emoji_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        emoji_id = crate::apis::urlencode(p_path_emoji_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_purge {
        req_builder = req_builder.query(&[("purge", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGuildEmojiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete guild role. Requires `manage_roles` permission. Permanently removes the role from the guild.
pub async fn delete_guild_role(
    configuration: &configuration::Configuration,
    guild_id: &str,
    role_id: &str,
) -> Result<(), Error<DeleteGuildRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_role_id = role_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles/{role_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        role_id = crate::apis::urlencode(p_path_role_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGuildRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete guild sticker. Requires `manage_emojis` permission. Removes a sticker from the guild; optionally purges all references.
pub async fn delete_guild_sticker(
    configuration: &configuration::Configuration,
    guild_id: &str,
    sticker_id: &str,
    purge: Option<&str>,
) -> Result<(), Error<DeleteGuildStickerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_sticker_id = sticker_id;
    let p_query_purge = purge;

    let uri_str = format!(
        "{}/guilds/{guild_id}/stickers/{sticker_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        sticker_id = crate::apis::urlencode(p_path_sticker_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_purge {
        req_builder = req_builder.query(&[("purge", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteGuildStickerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get current user guild member. Returns the member information for the authenticated user in the specified guild.
pub async fn get_current_guild_member(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<models::GuildMemberResponse, Error<GetCurrentGuildMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/@me",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildMemberResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildMemberResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCurrentGuildMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User must be a member of the guild to access this endpoint.
pub async fn get_guild(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<models::GuildResponse, Error<GetGuildError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGuildError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get guild member by user ID. Returns member information including roles, nickname, and join date for the specified user in the guild.
pub async fn get_guild_member(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
) -> Result<models::GuildMemberResponse, Error<GetGuildMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/{user_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildMemberResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildMemberResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGuildMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns the custom invite code for the guild if configured.
pub async fn get_guild_vanity_url(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<models::GuildVanityUrlResponse, Error<GetGuildVanityUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/vanity-url",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildVanityUrlResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildVanityUrlResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGuildVanityUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes the current user from the specified guild membership.
pub async fn leave_guild(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<(), Error<LeaveGuildError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/users/@me/guilds/{guild_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LeaveGuildError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild audit logs. Only default users can access. Requires `view_audit_logs` permission. Returns guild activity history with pagination and action filtering.
pub async fn list_guild_audit_logs(
    configuration: &configuration::Configuration,
    guild_id: &str,
    limit: Option<i32>,
    before: Option<&str>,
    after: Option<&str>,
    user_id: Option<&str>,
    action_type: Option<models::AuditLogActionType>,
) -> Result<models::GuildAuditLogListResponse, Error<ListGuildAuditLogsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_query_limit = limit;
    let p_query_before = before;
    let p_query_after = after;
    let p_query_user_id = user_id;
    let p_query_action_type = action_type;

    let uri_str = format!(
        "{}/guilds/{guild_id}/audit-logs",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_id {
        req_builder = req_builder.query(&[("user_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_action_type {
        req_builder = req_builder.query(&[("action_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildAuditLogListResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildAuditLogListResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildAuditLogsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild bans. Requires `ban_members` permission. Returns all banned users for the guild including ban reasons and expiry times.
pub async fn list_guild_bans(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<Vec<models::GuildBanResponse>, Error<ListGuildBansError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/bans",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GuildBanResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GuildBanResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildBansError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild channels. Returns all channels in the guild that the user has access to view.
pub async fn list_guild_channels(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<Vec<models::ChannelResponse>, Error<ListGuildChannelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/channels",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ChannelResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ChannelResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildChannelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild emojis. Returns all custom emojis for the guild including metadata about creators and timestamps.
pub async fn list_guild_emojis2(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<Vec<models::GuildEmojiWithUserResponse>, Error<ListGuildEmojis2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/emojis",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GuildEmojiWithUserResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GuildEmojiWithUserResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildEmojis2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild members. Supports pagination with limit and after cursor. Returns member information for the specified guild.
pub async fn list_guild_members2(
    configuration: &configuration::Configuration,
    guild_id: &str,
    limit: Option<i32>,
    after: Option<&str>,
) -> Result<Vec<models::GuildMemberResponse>, Error<ListGuildMembers2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_query_limit = limit;
    let p_query_after = after;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GuildMemberResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GuildMemberResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildMembers2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild roles. Returns all roles defined in the guild including their permissions and settings.
pub async fn list_guild_roles(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<Vec<models::GuildRoleResponse>, Error<ListGuildRolesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GuildRoleResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GuildRoleResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildRolesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List guild stickers. Returns all custom stickers for the guild including metadata about creators, descriptions, and tags.
pub async fn list_guild_stickers2(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<Vec<models::GuildStickerWithUserResponse>, Error<ListGuildStickers2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/stickers",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GuildStickerWithUserResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GuildStickerWithUserResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildStickers2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requires guilds OAuth scope if using bearer token. Returns all guilds the user is a member of.
pub async fn list_guilds(
    configuration: &configuration::Configuration,
    before: Option<&str>,
    after: Option<&str>,
    limit: Option<i32>,
    with_counts: Option<&str>,
) -> Result<Vec<models::GuildResponse>, Error<ListGuildsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_before = before;
    let p_query_after = after;
    let p_query_limit = limit;
    let p_query_with_counts = with_counts;

    let uri_str = format!("{}/users/@me/guilds", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_with_counts {
        req_builder = req_builder.query(&[("with_counts", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::GuildResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::GuildResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove guild member. Requires `kick_members` permission. Removes the specified user from the guild.
pub async fn remove_guild_member(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
) -> Result<(), Error<RemoveGuildMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/{user_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveGuildMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Remove role from guild member. Requires `manage_roles` permission. Revokes the specified role from the user in the guild.
pub async fn remove_guild_member_role(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
    role_id: &str,
) -> Result<(), Error<RemoveGuildMemberRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;
    let p_path_role_id = role_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/{user_id}/roles/{role_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id),
        role_id = crate::apis::urlencode(p_path_role_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveGuildMemberRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reset role hoist positions. Requires `manage_roles` permission. Clears all hoist position assignments for roles in the guild.
pub async fn reset_role_hoist_positions(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<(), Error<ResetRoleHoistPositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles/hoist-positions",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetRoleHoistPositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Search and filter guild members with pagination support.
pub async fn search_guild_members(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_member_search_request: models::GuildMemberSearchRequest,
) -> Result<models::GuildMemberSearchResponse, Error<SearchGuildMembersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_member_search_request = guild_member_search_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members-search",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_member_search_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildMemberSearchResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildMemberSearchResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchGuildMembersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requires `manage_guild` permission. Enables or disables independent banner display configuration.
pub async fn toggle_detached_banner(
    configuration: &configuration::Configuration,
    guild_id: &str,
    enabled_toggle_request: models::EnabledToggleRequest,
) -> Result<models::GuildResponse, Error<ToggleDetachedBannerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_enabled_toggle_request = enabled_toggle_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/detached-banner",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_enabled_toggle_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ToggleDetachedBannerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requires `manage_guild` permission. Allows or disables flexible naming for text channels.
pub async fn toggle_text_channel_flexible_names(
    configuration: &configuration::Configuration,
    guild_id: &str,
    enabled_toggle_request: models::EnabledToggleRequest,
) -> Result<models::GuildResponse, Error<ToggleTextChannelFlexibleNamesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_enabled_toggle_request = enabled_toggle_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/text-channel-flexible-names",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_enabled_toggle_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ToggleTextChannelFlexibleNamesError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Transfer guild ownership. Only current owner can transfer. Requires sudo mode verification (MFA). Transfers all guild permissions to a new owner.
pub async fn transfer_guild_ownership2(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_transfer_ownership_request: models::GuildTransferOwnershipRequest,
) -> Result<models::GuildResponse, Error<TransferGuildOwnership2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_transfer_ownership_request = guild_transfer_ownership_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/transfer-ownership",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_transfer_ownership_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<TransferGuildOwnership2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unban guild member. Requires `ban_members` permission. Removes ban and allows user to rejoin the guild.
pub async fn unban_guild_member(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
) -> Result<(), Error<UnbanGuildMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/bans/{user_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnbanGuildMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update current user guild member. User can modify their own nickname within the guild.
pub async fn update_current_guild_member(
    configuration: &configuration::Configuration,
    guild_id: &str,
    my_guild_member_update_request: models::MyGuildMemberUpdateRequest,
) -> Result<models::GuildMemberResponse, Error<UpdateCurrentGuildMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_my_guild_member_update_request = my_guild_member_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/@me",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_my_guild_member_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildMemberResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildMemberResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateCurrentGuildMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Requires `manage_guild` permission. Updates guild name, description, icon, banner, and other configuration options.
pub async fn update_guild(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_update_request: models::GuildUpdateRequest,
) -> Result<models::GuildResponse, Error<UpdateGuildError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_update_request = guild_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update channel positions. Requires `manage_channels` permission. Reorders channels and optionally changes parent categories and permission locks.
pub async fn update_guild_channel_positions(
    configuration: &configuration::Configuration,
    guild_id: &str,
    channel_position_update_request_inner: Vec<models::ChannelPositionUpdateRequestInner>,
) -> Result<(), Error<UpdateGuildChannelPositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_channel_position_update_request_inner = channel_position_update_request_inner;

    let uri_str = format!(
        "{}/guilds/{guild_id}/channels",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_channel_position_update_request_inner);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildChannelPositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update guild emoji. Requires `manage_emojis` permission. Renames or updates properties of an existing emoji.
pub async fn update_guild_emoji(
    configuration: &configuration::Configuration,
    guild_id: &str,
    emoji_id: &str,
    guild_emoji_update_request: models::GuildEmojiUpdateRequest,
) -> Result<models::GuildEmojiResponse, Error<UpdateGuildEmojiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_emoji_id = emoji_id;
    let p_body_guild_emoji_update_request = guild_emoji_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/emojis/{emoji_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        emoji_id = crate::apis::urlencode(p_path_emoji_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_emoji_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildEmojiResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildEmojiResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildEmojiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update guild member. Requires `manage_members` permission. Can modify member nickname, voice state, and other member properties.
pub async fn update_guild_member(
    configuration: &configuration::Configuration,
    guild_id: &str,
    user_id: &str,
    guild_member_update_request: models::GuildMemberUpdateRequest,
) -> Result<models::GuildMemberResponse, Error<UpdateGuildMemberError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_user_id = user_id;
    let p_body_guild_member_update_request = guild_member_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/members/{user_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_member_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildMemberResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildMemberResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildMemberError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update guild role. Requires `manage_roles` permission. Modifies role name, permissions, color, and other settings.
pub async fn update_guild_role(
    configuration: &configuration::Configuration,
    guild_id: &str,
    role_id: &str,
    guild_role_update_request: models::GuildRoleUpdateRequest,
) -> Result<models::GuildRoleResponse, Error<UpdateGuildRoleError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_role_id = role_id;
    let p_body_guild_role_update_request = guild_role_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles/{role_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        role_id = crate::apis::urlencode(p_path_role_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_role_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildRoleResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildRoleResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildRoleError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update role positions. Requires `manage_roles` permission. Reorders roles to change their hierarchy and permission precedence.
pub async fn update_guild_role_positions(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_role_position_item: Vec<models::GuildRolePositionItem>,
) -> Result<(), Error<UpdateGuildRolePositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_role_position_item = guild_role_position_item;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_role_position_item);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildRolePositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update guild sticker. Requires `manage_emojis` permission. Updates sticker name, description, or tags.
pub async fn update_guild_sticker(
    configuration: &configuration::Configuration,
    guild_id: &str,
    sticker_id: &str,
    guild_sticker_update_request: models::GuildStickerUpdateRequest,
) -> Result<models::GuildStickerResponse, Error<UpdateGuildStickerError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_path_sticker_id = sticker_id;
    let p_body_guild_sticker_update_request = guild_sticker_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/stickers/{sticker_id}",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id),
        sticker_id = crate::apis::urlencode(p_path_sticker_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_sticker_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildStickerResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildStickerResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildStickerError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Only default users can set vanity URLs. Requires `manage_guild` permission. Sets or removes a custom invite code.
pub async fn update_guild_vanity_url(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_vanity_url_update_request: models::GuildVanityUrlUpdateRequest,
) -> Result<models::GuildVanityUrlUpdateResponse, Error<UpdateGuildVanityUrlError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_vanity_url_update_request = guild_vanity_url_update_request;

    let uri_str = format!(
        "{}/guilds/{guild_id}/vanity-url",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_vanity_url_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::GuildVanityUrlUpdateResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GuildVanityUrlUpdateResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGuildVanityUrlError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update role hoist positions. Requires `manage_roles` permission. Sets the display priority for hoisted (separated) roles in the member list.
pub async fn update_role_hoist_positions(
    configuration: &configuration::Configuration,
    guild_id: &str,
    guild_role_hoist_position_item: Vec<models::GuildRoleHoistPositionItem>,
) -> Result<(), Error<UpdateRoleHoistPositionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;
    let p_body_guild_role_hoist_position_item = guild_role_hoist_position_item;

    let uri_str = format!(
        "{}/guilds/{guild_id}/roles/hoist-positions",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_guild_role_hoist_position_item);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateRoleHoistPositionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
