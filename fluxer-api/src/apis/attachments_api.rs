/*
 * Fluxer API
 *
 * API for Fluxer, a free and open source instant messaging and VoIP platform built for friends, groups, and communities.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developers@fluxer.app
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`complete_chunked_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteChunkedUploadError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_chunked_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChunkedUploadError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_chunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadChunkError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// Completes a chunked upload session by assembling all uploaded chunks. Requires `ETags` for all chunks. Returns the upload filename that can be referenced when sending a message with the uploaded file.
pub async fn complete_chunked_upload(
    configuration: &configuration::Configuration,
    channel_id: &str,
    upload_id: &str,
    complete_chunked_upload_request: models::CompleteChunkedUploadRequest,
) -> Result<models::CompleteChunkedUploadResponse, Error<CompleteChunkedUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_upload_id = upload_id;
    let p_body_complete_chunked_upload_request = complete_chunked_upload_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/chunked-uploads/{upload_id}/complete",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        upload_id = crate::apis::urlencode(p_path_upload_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_complete_chunked_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::CompleteChunkedUploadResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CompleteChunkedUploadResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteChunkedUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a new chunked upload session for uploading large files. Returns the upload ID, expected chunk size, and total chunk count. The client should then upload each chunk individually and complete the upload when all chunks are uploaded.
pub async fn create_chunked_upload(
    configuration: &configuration::Configuration,
    channel_id: &str,
    create_chunked_upload_request: models::CreateChunkedUploadRequest,
) -> Result<models::CreateChunkedUploadResponse, Error<CreateChunkedUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_create_chunked_upload_request = create_chunked_upload_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/chunked-uploads",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_create_chunked_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::CreateChunkedUploadResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::CreateChunkedUploadResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateChunkedUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Uploads a single chunk of a file as part of a chunked upload session. The chunk index is zero-based. Returns an `ETag` that must be provided when completing the upload.
pub async fn upload_chunk(
    configuration: &configuration::Configuration,
    channel_id: &str,
    upload_id: &str,
    chunk_index: &str,
) -> Result<models::UploadChunkResponse, Error<UploadChunkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_upload_id = upload_id;
    let p_path_chunk_index = chunk_index;

    let uri_str = format!(
        "{}/channels/{channel_id}/chunked-uploads/{upload_id}/chunks/{chunk_index}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        upload_id = crate::apis::urlencode(p_path_upload_id),
        chunk_index = crate::apis::urlencode(p_path_chunk_index)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::UploadChunkResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UploadChunkResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadChunkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
