/*
 * Fluxer API
 *
 * API for Fluxer, a free and open source instant messaging and VoIP platform built for friends, groups, and communities.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developers@fluxer.app
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`acknowledge_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcknowledgeMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`acknowledge_pins`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AcknowledgePinsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_group_dm_recipient`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddGroupDmRecipientError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`add_reaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddReactionError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`bulk_delete_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum BulkDeleteMessagesError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`clear_channel_read_state`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ClearChannelReadStateError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_chunked_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteChunkedUploadError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_chunked_upload`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChunkedUploadError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_channel_permission_overwrite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteChannelPermissionOverwriteError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_message2`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessage2Error {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_message_attachment`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteMessageAttachmentError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`end_call`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EndCallError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_call_eligibility`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCallEligibilityError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetChannelError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_stream_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetStreamPreviewError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`indicate_typing`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndicateTypingError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListMessagesError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_pinned_messages`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListPinnedMessagesError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_reaction_users`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListReactionUsersError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_rtc_regions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRtcRegionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`pin_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PinMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_all_reactions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAllReactionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_all_reactions_for_emoji`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAllReactionsForEmojiError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_group_dm_recipient`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveGroupDmRecipientError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_own_reaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveOwnReactionError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_reaction`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveReactionError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`ring_call_recipients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RingCallRecipientsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`schedule_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ScheduleMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_channel_permission_overwrite`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetChannelPermissionOverwriteError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_ringing_call_recipients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopRingingCallRecipientsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`unpin_message`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UnpinMessageError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_call_region`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateCallRegionError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChannelError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_stream_region`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateStreamRegionError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_chunk`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadChunkError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_stream_preview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadStreamPreviewError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// Marks a message as read and records acknowledgement state. Only available for regular user accounts. Updates mention count if provided. Returns 204 No Content on success.
pub async fn acknowledge_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    message_ack_request: models::MessageAckRequest,
) -> Result<(), Error<AcknowledgeMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_body_message_ack_request = message_ack_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/ack",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_message_ack_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AcknowledgeMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Marks all new pin notifications in a channel as acknowledged. Clears the notification badge for pinned messages. Returns 204 No Content on success.
pub async fn acknowledge_pins(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<(), Error<AcknowledgePinsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/pins/ack",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AcknowledgePinsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Adds a user to a group direct message channel. The requesting user must be a member of the group DM.
pub async fn add_group_dm_recipient(
    configuration: &configuration::Configuration,
    channel_id: &str,
    user_id: &str,
) -> Result<(), Error<AddGroupDmRecipientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_user_id = user_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/recipients/{user_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddGroupDmRecipientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Adds an emoji reaction to a message. Each user can react once with each emoji. Cannot be used from unclaimed accounts outside personal notes. Returns 204 No Content on success.
pub async fn add_reaction(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    emoji: &str,
    session_id: Option<&str>,
) -> Result<(), Error<AddReactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_path_emoji = emoji;
    let p_query_session_id = session_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id),
        emoji = crate::apis::urlencode(p_path_emoji)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref param_value) = p_query_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddReactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes multiple messages at once. Requires moderation or admin permissions. Commonly used for message cleanup. Messages from different authors can be deleted together. Returns 204 No Content on success.
pub async fn bulk_delete_messages(
    configuration: &configuration::Configuration,
    channel_id: &str,
    bulk_delete_messages_request: models::BulkDeleteMessagesRequest,
) -> Result<(), Error<BulkDeleteMessagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_bulk_delete_messages_request = bulk_delete_messages_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/bulk-delete",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_bulk_delete_messages_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<BulkDeleteMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Clears all read state and acknowledgement records for a channel, marking all messages as unread. Only available for regular user accounts. Returns 204 No Content on success.
pub async fn clear_channel_read_state(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<(), Error<ClearChannelReadStateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/ack",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ClearChannelReadStateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Completes a chunked upload session by assembling all uploaded chunks. Requires `ETags` for all chunks. Returns the upload filename that can be referenced when sending a message with the uploaded file.
pub async fn complete_chunked_upload(
    configuration: &configuration::Configuration,
    channel_id: &str,
    upload_id: &str,
    complete_chunked_upload_request: models::CompleteChunkedUploadRequest,
) -> Result<models::CompleteChunkedUploadResponse, Error<CompleteChunkedUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_upload_id = upload_id;
    let p_body_complete_chunked_upload_request = complete_chunked_upload_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/chunked-uploads/{upload_id}/complete",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        upload_id = crate::apis::urlencode(p_path_upload_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_complete_chunked_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CompleteChunkedUploadResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CompleteChunkedUploadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteChunkedUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates a new chunked upload session for uploading large files. Returns the upload ID, expected chunk size, and total chunk count. The client should then upload each chunk individually and complete the upload when all chunks are uploaded.
pub async fn create_chunked_upload(
    configuration: &configuration::Configuration,
    channel_id: &str,
    create_chunked_upload_request: models::CreateChunkedUploadRequest,
) -> Result<models::CreateChunkedUploadResponse, Error<CreateChunkedUploadError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_create_chunked_upload_request = create_chunked_upload_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/chunked-uploads",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_create_chunked_upload_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CreateChunkedUploadResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CreateChunkedUploadResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateChunkedUploadError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Permanently removes a channel and all its content. Only server administrators or the channel owner can delete channels.
pub async fn delete_channel(
    configuration: &configuration::Configuration,
    channel_id: &str,
    silent: Option<&str>,
) -> Result<(), Error<DeleteChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_query_silent = silent;

    let uri_str = format!(
        "{}/channels/{channel_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_silent {
        req_builder = req_builder.query(&[("silent", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes a permission override from a role or user in the channel, restoring default permissions. Requires channel management rights.
pub async fn delete_channel_permission_overwrite(
    configuration: &configuration::Configuration,
    channel_id: &str,
    overwrite_id: &str,
) -> Result<(), Error<DeleteChannelPermissionOverwriteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_overwrite_id = overwrite_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/permissions/{overwrite_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        overwrite_id = crate::apis::urlencode(p_path_overwrite_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteChannelPermissionOverwriteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes a message permanently. Only the message author can delete messages (or admins/moderators with proper permissions). Cannot be undone. Returns 204 No Content on success.
pub async fn delete_message2(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
) -> Result<(), Error<DeleteMessage2Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMessage2Error> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes a specific attachment from a message while keeping the message intact. Only the message author can remove attachments (or admins/moderators). Returns 204 No Content on success.
pub async fn delete_message_attachment(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    attachment_id: &str,
) -> Result<(), Error<DeleteMessageAttachmentError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_path_attachment_id = attachment_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/attachments/{attachment_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id),
        attachment_id = crate::apis::urlencode(p_path_attachment_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteMessageAttachmentError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates an existing message. Only the message author can edit messages (or admins with proper permissions). Supports updating content, embeds, and attachments. Returns the updated message object. Maintains original message ID and timestamps.
pub async fn edit_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
) -> Result<models::MessageResponseSchema, Error<EditMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageResponseSchema`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EditMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Terminates an active voice call in the channel. Records the call end state for all participants.
pub async fn end_call(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<(), Error<EndCallError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/call/end",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EndCallError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Checks whether a call can be initiated in the channel and if there is an active call. Returns ringable status and silent mode flag.
pub async fn get_call_eligibility(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<models::CallEligibilityResponse, Error<GetCallEligibilityError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/call",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::CallEligibilityResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::CallEligibilityResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCallEligibilityError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the channel object including metadata, member list, and settings. Requires the user to be a member of the channel with view permissions.
pub async fn get_channel(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<models::ChannelResponse, Error<GetChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChannelResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChannelResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves a specific message by ID. User must have permission to view the channel and the message must exist. Returns full message details including content, author, reactions, and attachments.
pub async fn get_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
) -> Result<models::MessageResponseSchema, Error<GetMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageResponseSchema`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves the current preview thumbnail for a stream. Returns the image with no-store cache headers to ensure freshness.
pub async fn get_stream_preview(
    configuration: &configuration::Configuration,
    stream_key: &str,
) -> Result<(), Error<GetStreamPreviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stream_key = stream_key;

    let uri_str = format!(
        "{}/streams/{stream_key}/preview",
        configuration.base_path,
        stream_key = crate::apis::urlencode(p_path_stream_key)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetStreamPreviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Notifies other users in the channel that you are actively typing. Typing indicators typically expire after a short period (usually 10 seconds). Returns 204 No Content. Commonly called repeatedly while the user is composing a message.
pub async fn indicate_typing(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<(), Error<IndicateTypingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/typing",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<IndicateTypingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves a paginated list of messages from a channel. User must have permission to view the channel. Supports pagination via limit, before, after, and around parameters. Returns messages in reverse chronological order (newest first).
pub async fn list_messages(
    configuration: &configuration::Configuration,
    channel_id: &str,
    limit: Option<&str>,
    before: Option<&str>,
    after: Option<&str>,
    around: Option<&str>,
) -> Result<Vec<models::MessageResponseSchema>, Error<ListMessagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_query_limit = limit;
    let p_query_before = before;
    let p_query_after = after;
    let p_query_around = around;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_around {
        req_builder = req_builder.query(&[("around", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::MessageResponseSchema&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::MessageResponseSchema&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves a paginated list of messages pinned in a channel. User must have permission to view the channel. Supports pagination via limit and before parameters. Returns pinned messages with their pin timestamps.
pub async fn list_pinned_messages(
    configuration: &configuration::Configuration,
    channel_id: &str,
    limit: Option<i32>,
    before: Option<String>,
) -> Result<models::ChannelPinsResponse, Error<ListPinnedMessagesError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_query_limit = limit;
    let p_query_before = before;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/pins",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_before {
        req_builder = req_builder.query(&[("before", &param_value.clone())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChannelPinsResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChannelPinsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListPinnedMessagesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves a paginated list of users who reacted to a message with a specific emoji. Supports pagination via limit and after parameters. Returns user objects for each reaction.
pub async fn list_reaction_users(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    emoji: &str,
    limit: Option<i32>,
    after: Option<&str>,
) -> Result<Vec<models::UserPartialResponse>, Error<ListReactionUsersError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_path_emoji = emoji;
    let p_query_limit = limit;
    let p_query_after = after;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id),
        emoji = crate::apis::urlencode(p_path_emoji)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_after {
        req_builder = req_builder.query(&[("after", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UserPartialResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UserPartialResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListReactionUsersError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns available voice and video calling regions for the channel, used to optimise connection quality. Requires membership with call permissions.
pub async fn list_rtc_regions(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<Vec<models::RtcRegionResponse>, Error<ListRtcRegionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/rtc-regions",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::RtcRegionResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::RtcRegionResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListRtcRegionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Pins a message to the channel. Requires permission to manage pins (typically moderator or higher). Pinned messages are highlighted and searchable. Returns 204 No Content on success.
pub async fn pin_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
) -> Result<(), Error<PinMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/pins/{message_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PinMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes all emoji reactions from a message, regardless of emoji type or user. All reactions are permanently deleted. Requires moderator or higher permissions. Returns 204 No Content on success.
pub async fn remove_all_reactions(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
) -> Result<(), Error<RemoveAllReactionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/reactions",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveAllReactionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes all emoji reactions of a specific type from a message. All users' reactions with that emoji are deleted. Requires moderator or higher permissions. Returns 204 No Content on success.
pub async fn remove_all_reactions_for_emoji(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    emoji: &str,
) -> Result<(), Error<RemoveAllReactionsForEmojiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_path_emoji = emoji;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id),
        emoji = crate::apis::urlencode(p_path_emoji)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveAllReactionsForEmojiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes a user from a group direct message channel. The requesting user must be a member with appropriate permissions.
pub async fn remove_group_dm_recipient(
    configuration: &configuration::Configuration,
    channel_id: &str,
    user_id: &str,
    silent: Option<&str>,
) -> Result<(), Error<RemoveGroupDmRecipientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_user_id = user_id;
    let p_query_silent = silent;

    let uri_str = format!(
        "{}/channels/{channel_id}/recipients/{user_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        user_id = crate::apis::urlencode(p_path_user_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_silent {
        req_builder = req_builder.query(&[("silent", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveGroupDmRecipientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes your own emoji reaction from a message. Returns 204 No Content on success. Has no effect if you haven't reacted with that emoji.
pub async fn remove_own_reaction(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    emoji: &str,
    session_id: Option<&str>,
) -> Result<(), Error<RemoveOwnReactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_path_emoji = emoji;
    let p_query_session_id = session_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/@me",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id),
        emoji = crate::apis::urlencode(p_path_emoji)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveOwnReactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Removes a specific user's emoji reaction from a message. Requires moderator or higher permissions to remove reactions from other users. Returns 204 No Content on success.
pub async fn remove_reaction(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
    emoji: &str,
    target_id: &str,
    session_id: Option<&str>,
) -> Result<(), Error<RemoveReactionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;
    let p_path_emoji = emoji;
    let p_path_target_id = target_id;
    let p_query_session_id = session_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/{message_id}/reactions/{emoji}/{target_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id),
        emoji = crate::apis::urlencode(p_path_emoji),
        target_id = crate::apis::urlencode(p_path_target_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref param_value) = p_query_session_id {
        req_builder = req_builder.query(&[("session_id", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveReactionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends ringing notifications to specified users in a call. If no recipients are specified, rings all channel members.
pub async fn ring_call_recipients(
    configuration: &configuration::Configuration,
    channel_id: &str,
    call_ring_body_schema: models::CallRingBodySchema,
) -> Result<(), Error<RingCallRecipientsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_call_ring_body_schema = call_ring_body_schema;

    let uri_str = format!(
        "{}/channels/{channel_id}/call/ring",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_call_ring_body_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RingCallRecipientsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Schedules a message to be sent at a specified time. Only available for regular user accounts. Requires permission to send messages in the target channel. Message is sent automatically at the scheduled time. Returns the scheduled message object with delivery time.
pub async fn schedule_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<models::ScheduledMessageResponseSchema, Error<ScheduleMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages/schedule",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScheduledMessageResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScheduledMessageResponseSchema`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ScheduleMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Sends a new message to a channel. Requires permission to send messages in the target channel. Supports text content, embeds, attachments (multipart), and mentions. Returns the created message object with full details.
pub async fn send_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<models::MessageResponseSchema, Error<SendMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/messages",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageResponseSchema`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SendMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Creates or updates permission overrides for a role or user in the channel. Allows fine-grained control over who can view, send messages, or manage the channel.
pub async fn set_channel_permission_overwrite(
    configuration: &configuration::Configuration,
    channel_id: &str,
    overwrite_id: &str,
    permission_overwrite_create_request: models::PermissionOverwriteCreateRequest,
) -> Result<(), Error<SetChannelPermissionOverwriteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_overwrite_id = overwrite_id;
    let p_body_permission_overwrite_create_request = permission_overwrite_create_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/permissions/{overwrite_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        overwrite_id = crate::apis::urlencode(p_path_overwrite_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_permission_overwrite_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetChannelPermissionOverwriteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Stops ringing notifications for specified users in a call. Allows callers to stop notifying users who have declined or not responded.
pub async fn stop_ringing_call_recipients(
    configuration: &configuration::Configuration,
    channel_id: &str,
    call_ring_body_schema: models::CallRingBodySchema,
) -> Result<(), Error<StopRingingCallRecipientsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_call_ring_body_schema = call_ring_body_schema;

    let uri_str = format!(
        "{}/channels/{channel_id}/call/stop-ringing",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_call_ring_body_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StopRingingCallRecipientsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Unpins a message from the channel. Requires permission to manage pins. The message remains in the channel but is no longer highlighted. Returns 204 No Content on success.
pub async fn unpin_message(
    configuration: &configuration::Configuration,
    channel_id: &str,
    message_id: &str,
) -> Result<(), Error<UnpinMessageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_message_id = message_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/pins/{message_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        message_id = crate::apis::urlencode(p_path_message_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UnpinMessageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Changes the voice server region for an active call to optimise latency and connection quality.
pub async fn update_call_region(
    configuration: &configuration::Configuration,
    channel_id: &str,
    call_update_body_schema: models::CallUpdateBodySchema,
) -> Result<(), Error<UpdateCallRegionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_call_update_body_schema = call_update_body_schema;

    let uri_str = format!(
        "{}/channels/{channel_id}/call",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_call_update_body_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateCallRegionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Modifies channel properties such as name, description, topic, nsfw flag, and slowmode. Requires management permissions in the channel.
pub async fn update_channel(
    configuration: &configuration::Configuration,
    channel_id: &str,
    channel_update_request: models::ChannelUpdateRequest,
) -> Result<models::ChannelResponse, Error<UpdateChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_channel_update_request = channel_update_request;

    let uri_str = format!(
        "{}/channels/{channel_id}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_channel_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChannelResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChannelResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Changes the media server region for an active stream. Used to optimise bandwidth and latency for streaming.
pub async fn update_stream_region(
    configuration: &configuration::Configuration,
    stream_key: &str,
    stream_update_body_schema: models::StreamUpdateBodySchema,
) -> Result<(), Error<UpdateStreamRegionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stream_key = stream_key;
    let p_body_stream_update_body_schema = stream_update_body_schema;

    let uri_str = format!(
        "{}/streams/{stream_key}/stream",
        configuration.base_path,
        stream_key = crate::apis::urlencode(p_path_stream_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_stream_update_body_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateStreamRegionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Uploads a single chunk of a file as part of a chunked upload session. The chunk index is zero-based. Returns an `ETag` that must be provided when completing the upload.
pub async fn upload_chunk(
    configuration: &configuration::Configuration,
    channel_id: &str,
    upload_id: &str,
    chunk_index: &str,
) -> Result<models::UploadChunkResponse, Error<UploadChunkError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_path_upload_id = upload_id;
    let p_path_chunk_index = chunk_index;

    let uri_str = format!(
        "{}/channels/{channel_id}/chunked-uploads/{upload_id}/chunks/{chunk_index}",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id),
        upload_id = crate::apis::urlencode(p_path_upload_id),
        chunk_index = crate::apis::urlencode(p_path_chunk_index)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UploadChunkResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UploadChunkResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadChunkError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Uploads a custom thumbnail image for the stream. The image is scanned for content policy violations and stored securely.
pub async fn upload_stream_preview(
    configuration: &configuration::Configuration,
    stream_key: &str,
    stream_preview_upload_body_schema: models::StreamPreviewUploadBodySchema,
) -> Result<(), Error<UploadStreamPreviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stream_key = stream_key;
    let p_body_stream_preview_upload_body_schema = stream_preview_upload_body_schema;

    let uri_str = format!(
        "{}/streams/{stream_key}/preview",
        configuration.base_path,
        stream_key = crate::apis::urlencode(p_path_stream_key)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_stream_preview_upload_body_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadStreamPreviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
