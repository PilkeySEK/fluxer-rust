/*
 * Fluxer API
 *
 * API for Fluxer, a free and open source instant messaging and VoIP platform built for friends, groups, and communities.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developers@fluxer.app
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateWebhookError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_webhook_with_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteWebhookWithTokenError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_github_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteGithubWebhookError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_sentry_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteSentryWebhookError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_slack_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteSlackWebhookError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`execute_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExecuteWebhookError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhookError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webhook_with_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebhookWithTokenError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_channel_webhooks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChannelWebhooksError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_guild_webhooks`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGuildWebhooksError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_webhook`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_webhook_with_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateWebhookWithTokenError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// Creates a new webhook in the specified channel with the provided name and optional avatar. Returns the newly created webhook object including its ID and token.
pub async fn create_webhook(
    configuration: &configuration::Configuration,
    channel_id: &str,
    webhook_create_request: models::WebhookCreateRequest,
) -> Result<models::WebhookResponse, Error<CreateWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;
    let p_body_webhook_create_request = webhook_create_request;

    let uri_str = format!(
        "{}/channels/{channel_id}/webhooks",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_webhook_create_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Permanently deletes the specified webhook. This action cannot be undone. Returns a 204 status code on successful deletion.
pub async fn delete_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
) -> Result<(), Error<DeleteWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Permanently deletes the specified webhook using its ID and token for authentication. This action cannot be undone. Returns a 204 status code on successful deletion.
pub async fn delete_webhook_with_token(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
) -> Result<(), Error<DeleteWebhookWithTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteWebhookWithTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Receives and processes GitHub webhook events, formatting them as messages in the configured channel. Reads event type from X-GitHub-Event header and delivery ID from X-GitHub-Delivery header.
pub async fn execute_github_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
    git_hub_webhook: models::GitHubWebhook,
) -> Result<(), Error<ExecuteGithubWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;
    let p_body_git_hub_webhook = git_hub_webhook;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}/github",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_git_hub_webhook);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteGithubWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Receives and processes Sentry error tracking webhook events, formatting them as messages in the configured channel. Reads event type from X-Sentry-Event header.
pub async fn execute_sentry_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
    sentry_webhook: models::SentryWebhook,
) -> Result<(), Error<ExecuteSentryWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;
    let p_body_sentry_webhook = sentry_webhook;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}/sentry",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_sentry_webhook);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteSentryWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Receives and processes Slack-formatted webhook payloads, converting them to messages in the configured channel. Returns \"ok\" as plain text with a 200 status code.
pub async fn execute_slack_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
    slack_webhook_request: models::SlackWebhookRequest,
) -> Result<String, Error<ExecuteSlackWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;
    let p_body_slack_webhook_request = slack_webhook_request;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}/slack",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_slack_webhook_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `String`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `String`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteSlackWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Executes the webhook by sending a message to its configured channel. If the wait query parameter is true, returns the created message object; otherwise returns a 204 status with no content.
pub async fn execute_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
    wait: Option<&str>,
) -> Result<models::MessageResponseSchema, Error<ExecuteWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;
    let p_query_wait = wait;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_wait {
        req_builder = req_builder.query(&[("wait", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MessageResponseSchema`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MessageResponseSchema`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ExecuteWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves detailed information about a specific webhook by its ID. Requires authentication and appropriate permissions to access the webhook.
pub async fn get_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
) -> Result<models::WebhookResponse, Error<GetWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieves detailed information about a specific webhook using its ID and token. No authentication required as the token serves as the credential. Returns the webhook object without creator user data.
pub async fn get_webhook_with_token(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
) -> Result<models::WebhookTokenResponse, Error<GetWebhookWithTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebhookWithTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of all webhooks configured in the specified channel. Requires the user to have appropriate permissions to view webhooks in the channel.
pub async fn list_channel_webhooks(
    configuration: &configuration::Configuration,
    channel_id: &str,
) -> Result<Vec<models::WebhookResponse>, Error<ListChannelWebhooksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_channel_id = channel_id;

    let uri_str = format!(
        "{}/channels/{channel_id}/webhooks",
        configuration.base_path,
        channel_id = crate::apis::urlencode(p_path_channel_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WebhookResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WebhookResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListChannelWebhooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Returns a list of all webhooks configured in the specified guild. Requires the user to have appropriate permissions to view webhooks in the guild.
pub async fn list_guild_webhooks(
    configuration: &configuration::Configuration,
    guild_id: &str,
) -> Result<Vec<models::WebhookResponse>, Error<ListGuildWebhooksError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_guild_id = guild_id;

    let uri_str = format!(
        "{}/guilds/{guild_id}/webhooks",
        configuration.base_path,
        guild_id = crate::apis::urlencode(p_path_guild_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::WebhookResponse&gt;`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::WebhookResponse&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGuildWebhooksError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates the specified webhook with new settings such as name, avatar, or target channel. All fields are optional. Returns the updated webhook object.
pub async fn update_webhook(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    webhook_update_request: models::WebhookUpdateRequest,
) -> Result<models::WebhookResponse, Error<UpdateWebhookError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_body_webhook_update_request = webhook_update_request;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_webhook_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateWebhookError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Updates the specified webhook using its ID and token for authentication. Allows modification of name or avatar. Returns the updated webhook object without creator user data.
pub async fn update_webhook_with_token(
    configuration: &configuration::Configuration,
    webhook_id: &str,
    token: &str,
    webhook_token_update_request: models::WebhookTokenUpdateRequest,
) -> Result<models::WebhookTokenResponse, Error<UpdateWebhookWithTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_webhook_id = webhook_id;
    let p_path_token = token;
    let p_body_webhook_token_update_request = webhook_token_update_request;

    let uri_str = format!(
        "{}/webhooks/{webhook_id}/{token}",
        configuration.base_path,
        webhook_id = crate::apis::urlencode(p_path_webhook_id),
        token = crate::apis::urlencode(p_path_token)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_webhook_token_update_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebhookTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebhookTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateWebhookWithTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
