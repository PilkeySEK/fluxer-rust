/*
 * Fluxer API
 *
 * API for Fluxer, a free and open source instant messaging and VoIP platform built for friends, groups, and communities.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: developers@fluxer.app
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`authenticate_with_webauthn`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthenticateWithWebauthnError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`authorize_ip_address`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AuthorizeIpAddressError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_handoff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelHandoffError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_handoff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteHandoffError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`complete_sso`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CompleteSsoError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`forgot_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ForgotPasswordError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_handoff_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetHandoffStatusError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_sso_status`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSsoStatusError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_username_suggestions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetUsernameSuggestionsError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webauthn_authentication_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebauthnAuthenticationOptionsError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_webauthn_mfa_options`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetWebauthnMfaOptionsError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`initiate_handoff`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum InitiateHandoffError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_auth_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListAuthSessionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginUserError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_with_sms_mfa`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginWithSmsMfaError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_with_totp`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginWithTotpError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`login_with_webauthn_mfa`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LoginWithWebauthnMfaError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logout_all_sessions`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogoutAllSessionsError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`logout_user`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum LogoutUserError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`poll_ip_authorization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PollIpAuthorizationError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`register_account`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RegisterAccountError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resend_ip_authorization`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResendIpAuthorizationError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`resend_verification_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResendVerificationEmailError {
    Status400(models::Error),
    Status401(models::Error),
    Status403(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`reset_password`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ResetPasswordError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revert_email_change`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevertEmailChangeError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`send_sms_mfa_code`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SendSmsMfaCodeError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`start_sso`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StartSsoError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_email`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyEmailError {
    Status400(models::Error),
    Status429(models::GetWellKnownFluxer429Response),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// Complete passwordless login using `WebAuthn` (biometrics or security key). Returns authentication token on success.
pub async fn authenticate_with_webauthn(
    configuration: &configuration::Configuration,
    web_authn_authenticate_request: models::WebAuthnAuthenticateRequest,
) -> Result<models::AuthTokenWithUserIdResponse, Error<AuthenticateWithWebauthnError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_authenticate_request = web_authn_authenticate_request;

    let uri_str = format!("{}/auth/webauthn/authenticate", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_web_authn_authenticate_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthenticateWithWebauthnError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verify and authorize a new IP address using the confirmation code sent via email. Completes IP authorization flow.
pub async fn authorize_ip_address(
    configuration: &configuration::Configuration,
    authorize_ip_request: models::AuthorizeIpRequest,
) -> Result<(), Error<AuthorizeIpAddressError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authorize_ip_request = authorize_ip_request;

    let uri_str = format!("{}/auth/authorize-ip", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_authorize_ip_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AuthorizeIpAddressError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Cancel an ongoing handoff session. The handoff code will no longer be valid for authentication.
pub async fn cancel_handoff(
    configuration: &configuration::Configuration,
    code: &str,
) -> Result<(), Error<CancelHandoffError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_code = code;

    let uri_str = format!(
        "{}/auth/handoff/{code}",
        configuration.base_path,
        code = crate::apis::urlencode(p_path_code)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelHandoffError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Complete the handoff process and authenticate on the target device using the handoff code.
pub async fn complete_handoff(
    configuration: &configuration::Configuration,
    handoff_complete_request: models::HandoffCompleteRequest,
) -> Result<(), Error<CompleteHandoffError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_handoff_complete_request = handoff_complete_request;

    let uri_str = format!("{}/auth/handoff/complete", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_handoff_complete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteHandoffError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Complete the SSO authentication flow with the authorization code from the SSO provider. Returns authentication token and user information.
pub async fn complete_sso(
    configuration: &configuration::Configuration,
    sso_complete_request: models::SsoCompleteRequest,
) -> Result<models::SsoCompleteResponse, Error<CompleteSsoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_sso_complete_request = sso_complete_request;

    let uri_str = format!("{}/auth/sso/complete", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_sso_complete_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SsoCompleteResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SsoCompleteResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CompleteSsoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Initiate password reset process by email. A password reset link will be sent to the user's email address. Requires CAPTCHA verification.
pub async fn forgot_password(
    configuration: &configuration::Configuration,
    forgot_password_request: models::ForgotPasswordRequest,
) -> Result<(), Error<ForgotPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_forgot_password_request = forgot_password_request;

    let uri_str = format!("{}/auth/forgot", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_forgot_password_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ForgotPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check the status of a handoff session. Returns whether the handoff has been completed or is still pending.
pub async fn get_handoff_status(
    configuration: &configuration::Configuration,
    code: &str,
) -> Result<models::HandoffStatusResponse, Error<GetHandoffStatusError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_code = code;

    let uri_str = format!(
        "{}/auth/handoff/{code}/status",
        configuration.base_path,
        code = crate::apis::urlencode(p_path_code)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::HandoffStatusResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::HandoffStatusResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetHandoffStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve the current status of the SSO authentication session without authentication required.
pub async fn get_sso_status(
    configuration: &configuration::Configuration,
) -> Result<models::SsoStatusResponse, Error<GetSsoStatusError>> {
    let uri_str = format!("{}/auth/sso/status", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SsoStatusResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SsoStatusResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetSsoStatusError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Generate username suggestions based on a provided global name for new account registration.
pub async fn get_username_suggestions(
    configuration: &configuration::Configuration,
    username_suggestions_request: models::UsernameSuggestionsRequest,
) -> Result<models::UsernameSuggestionsResponse, Error<GetUsernameSuggestionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_username_suggestions_request = username_suggestions_request;

    let uri_str = format!("{}/auth/username-suggestions", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_username_suggestions_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::UsernameSuggestionsResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UsernameSuggestionsResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetUsernameSuggestionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve `WebAuthn` authentication challenge and options for passwordless login with biometrics or security keys.
pub async fn get_webauthn_authentication_options(
    configuration: &configuration::Configuration,
) -> Result<serde_json::Value, Error<GetWebauthnAuthenticationOptionsError>> {
    let uri_str = format!(
        "{}/auth/webauthn/authentication-options",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebauthnAuthenticationOptionsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve `WebAuthn` challenge and options for multi-factor authentication. Requires the MFA ticket from initial login.
pub async fn get_webauthn_mfa_options(
    configuration: &configuration::Configuration,
    mfa_ticket_request: models::MfaTicketRequest,
) -> Result<serde_json::Value, Error<GetWebauthnMfaOptionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_mfa_ticket_request = mfa_ticket_request;

    let uri_str = format!(
        "{}/auth/login/mfa/webauthn/authentication-options",
        configuration.base_path
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mfa_ticket_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetWebauthnMfaOptionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Start a handoff session to transfer authentication between devices. Returns a handoff code for device linking.
pub async fn initiate_handoff(
    configuration: &configuration::Configuration,
) -> Result<models::HandoffInitiateResponse, Error<InitiateHandoffError>> {
    let uri_str = format!("{}/auth/handoff/initiate", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::HandoffInitiateResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::HandoffInitiateResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<InitiateHandoffError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Retrieve all active authentication sessions for the current user. Requires authentication.
pub async fn list_auth_sessions(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::AuthSessionResponse>, Error<ListAuthSessionsError>> {
    let uri_str = format!("{}/auth/sessions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::AuthSessionResponse&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::AuthSessionResponse&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListAuthSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Authenticate with email and password. Returns authentication token if credentials are valid and MFA is not required. If MFA is enabled, returns a ticket for MFA verification.
pub async fn login_user(
    configuration: &configuration::Configuration,
    login_request: models::LoginRequest,
) -> Result<models::AuthLoginResponse, Error<LoginUserError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_login_request = login_request;

    let uri_str = format!("{}/auth/login", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_login_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthLoginResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthLoginResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Complete login by verifying the SMS code sent during MFA authentication. Requires the MFA ticket from initial login attempt.
pub async fn login_with_sms_mfa(
    configuration: &configuration::Configuration,
    mfa_sms_request: models::MfaSmsRequest,
) -> Result<models::AuthTokenWithUserIdResponse, Error<LoginWithSmsMfaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_mfa_sms_request = mfa_sms_request;

    let uri_str = format!("{}/auth/login/mfa/sms", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mfa_sms_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginWithSmsMfaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Complete login by verifying TOTP code during multi-factor authentication. Requires the MFA ticket from initial login attempt.
pub async fn login_with_totp(
    configuration: &configuration::Configuration,
    mfa_totp_request: models::MfaTotpRequest,
) -> Result<models::AuthTokenWithUserIdResponse, Error<LoginWithTotpError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_mfa_totp_request = mfa_totp_request;

    let uri_str = format!("{}/auth/login/mfa/totp", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mfa_totp_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginWithTotpError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Complete login by verifying `WebAuthn` response during MFA. Requires the MFA ticket from initial login attempt.
pub async fn login_with_webauthn_mfa(
    configuration: &configuration::Configuration,
    web_authn_mfa_request: models::WebAuthnMfaRequest,
) -> Result<models::AuthTokenWithUserIdResponse, Error<LoginWithWebauthnMfaError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_web_authn_mfa_request = web_authn_mfa_request;

    let uri_str = format!("{}/auth/login/mfa/webauthn", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_web_authn_mfa_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthTokenWithUserIdResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<LoginWithWebauthnMfaError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invalidate all active authentication sessions for the current user. Requires sudo mode verification for security.
pub async fn logout_all_sessions(
    configuration: &configuration::Configuration,
    logout_auth_sessions_request: models::LogoutAuthSessionsRequest,
) -> Result<(), Error<LogoutAllSessionsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_logout_auth_sessions_request = logout_auth_sessions_request;

    let uri_str = format!("{}/auth/sessions/logout", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }
    req_builder = req_builder.json(&p_body_logout_auth_sessions_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogoutAllSessionsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invalidate the current authentication token and end the session. The auth token in the Authorization header will no longer be valid.
pub async fn logout_user(
    configuration: &configuration::Configuration,
) -> Result<(), Error<LogoutUserError>> {
    let uri_str = format!("{}/auth/logout", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<LogoutUserError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Poll the status of an IP authorization request. Use the ticket parameter to check if verification has been completed.
pub async fn poll_ip_authorization(
    configuration: &configuration::Configuration,
    ticket: &str,
) -> Result<models::IpAuthorizationPollResponse, Error<PollIpAuthorizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ticket = ticket;

    let uri_str = format!("{}/auth/ip-authorization/poll", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("ticket", &p_query_ticket.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::IpAuthorizationPollResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::IpAuthorizationPollResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PollIpAuthorizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new user account with email and password. Requires CAPTCHA verification. User account is created but must verify email before logging in.
pub async fn register_account(
    configuration: &configuration::Configuration,
    register_request: models::RegisterRequest,
) -> Result<models::AuthRegisterResponse, Error<RegisterAccountError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_register_request = register_request;

    let uri_str = format!("{}/auth/register", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_register_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthRegisterResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthRegisterResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RegisterAccountError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Request a new IP authorization verification code to be sent via email. Use if the original code was lost or expired.
pub async fn resend_ip_authorization(
    configuration: &configuration::Configuration,
    mfa_ticket_request: models::MfaTicketRequest,
) -> Result<(), Error<ResendIpAuthorizationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_mfa_ticket_request = mfa_ticket_request;

    let uri_str = format!("{}/auth/ip-authorization/resend", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mfa_ticket_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ResendIpAuthorizationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Request a new email verification code to be sent. Requires authentication. Use this if the original verification email was lost or expired.
pub async fn resend_verification_email(
    configuration: &configuration::Configuration,
) -> Result<(), Error<ResendVerificationEmailError>> {
    let uri_str = format!("{}/auth/verify/resend", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref apikey) = configuration.api_key {
        let key = apikey.key.clone();
        let value = match apikey.prefix {
            Some(ref prefix) => format!("{prefix} {key}"),
            None => key,
        };
        req_builder = req_builder.header("Authorization", value);
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ResendVerificationEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Complete the password reset flow using the token from the reset email. Returns authentication token after successful password reset.
pub async fn reset_password(
    configuration: &configuration::Configuration,
    reset_password_request: models::ResetPasswordRequest,
) -> Result<models::AuthLoginResponse, Error<ResetPasswordError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_reset_password_request = reset_password_request;

    let uri_str = format!("{}/auth/reset", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_reset_password_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthLoginResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthLoginResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ResetPasswordError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Revert a pending email change using the verification token sent to the old email. Returns authentication token after successful revert.
pub async fn revert_email_change(
    configuration: &configuration::Configuration,
    email_revert_request: models::EmailRevertRequest,
) -> Result<models::AuthLoginResponse, Error<RevertEmailChangeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_email_revert_request = email_revert_request;

    let uri_str = format!("{}/auth/email-revert", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_email_revert_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::AuthLoginResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::AuthLoginResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RevertEmailChangeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Request an SMS code to be sent to the user's registered phone number during MFA login. Requires the MFA ticket from initial login attempt.
pub async fn send_sms_mfa_code(
    configuration: &configuration::Configuration,
    mfa_ticket_request: models::MfaTicketRequest,
) -> Result<(), Error<SendSmsMfaCodeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_mfa_ticket_request = mfa_ticket_request;

    let uri_str = format!("{}/auth/login/mfa/sms/send", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_mfa_ticket_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SendSmsMfaCodeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Initiate a new Single Sign-On (SSO) session. Returns a session URL to be completed with SSO provider credentials.
pub async fn start_sso(
    configuration: &configuration::Configuration,
    sso_start_request: models::SsoStartRequest,
) -> Result<models::SsoStartResponse, Error<StartSsoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_sso_start_request = sso_start_request;

    let uri_str = format!("{}/auth/sso/start", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_sso_start_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::SsoStartResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SsoStartResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StartSsoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verify user email address using the code sent during registration. Email verification is required before the account becomes fully usable.
pub async fn verify_email(
    configuration: &configuration::Configuration,
    verify_email_request: models::VerifyEmailRequest,
) -> Result<(), Error<VerifyEmailError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_verify_email_request = verify_email_request;

    let uri_str = format!("{}/auth/verify", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_verify_email_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyEmailError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
